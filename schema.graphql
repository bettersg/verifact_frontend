schema {
  query: Query
  mutation: Mutation
}

input AnswerCreateInput {
  answer: String!
  text: String
  citationUrl: Url
  citationTitle: String
  questionId: ID!
  clientMutationId: String
}

type AnswerCreatePayload {
  answer: AnswerNode
  clientMutationId: String
}

type AnswerNode implements Node {
  id: ID!
  createdAt: DateTime!
  answer: String!
  text: String!
  citationUrl: String!
  citationTitle: String!
  question: QuestionNode!
  user: UserType!
  votes(offset: Int, before: String, after: String, first: Int, last: Int): VoteNodeConnection!
}

type AnswerNodeConnection {
  pageInfo: PageInfo!
  edges: [AnswerNodeEdge]!
}

type AnswerNodeEdge {
  node: AnswerNode
  cursor: String!
}

scalar DateTime

scalar Email

scalar GenericScalar

type Mutation {
  questionCreate(input: QuestionCreateInput!): QuestionCreatePayload
  answerCreate(input: AnswerCreateInput!): AnswerCreatePayload
  voteCreateUpdateDelete(input: VoteCreateUpdateDeleteInput!): VoteCreateUpdateDeletePayload
  userCreate(input: UserCreateInput!): UserCreatePayload
  userUpdate(input: UserUpdateInput!): UserUpdatePayload
  tokenAuth(input: ObtainJSONWebTokenInput!): ObtainJSONWebTokenPayload
  verifyToken(input: VerifyInput!): VerifyPayload
  refreshToken(input: RefreshInput!): RefreshPayload
}

interface Node {
  id: ID!
}

input ObtainJSONWebTokenInput {
  clientMutationId: String
  username: String!
  password: String!
}

type ObtainJSONWebTokenPayload {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  clientMutationId: String
  token: String!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  questions(before: String, after: String, first: Int, last: Int): QuestionConnection
  node(id: ID!): Node
  viewer: UserType
}

type QuestionConnection {
  pageInfo: PageInfo!
  edges: [QuestionEdge]!
}

input QuestionCreateInput {
  text: String!
  citationUrl: Url!
  citationTitle: String
  citationImageUrl: Url
  clientMutationId: String
}

type QuestionCreatePayload {
  question: QuestionNode
  clientMutationId: String
}

type QuestionEdge {
  node: QuestionNode
  cursor: String!
}

type QuestionNode implements Node {
  id: ID!
  createdAt: DateTime!
  text: String!
  citationUrl: String!
  citationTitle: String!
  citationImageUrl: String!
  user: UserType!
  answers(offset: Int, before: String, after: String, first: Int, last: Int): AnswerNodeConnection!
}

type QuestionNodeConnection {
  pageInfo: PageInfo!
  edges: [QuestionNodeEdge]!
}

type QuestionNodeEdge {
  node: QuestionNode
  cursor: String!
}

input RefreshInput {
  token: String
  clientMutationId: String
}

type RefreshPayload {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  clientMutationId: String
  token: String!
}

scalar Url

input UserCreateInput {
  username: String!
  email: Email!
  password: String!
  clientMutationId: String
}

type UserCreatePayload {
  user: UserType
  clientMutationId: String
}

type UserType {
  id: ID!
  password: String!
  lastLogin: DateTime
  isSuperuser: Boolean!
  username: String!
  firstName: String!
  lastName: String!
  email: String!
  isStaff: Boolean!
  isActive: Boolean!
  dateJoined: DateTime!
  questions(offset: Int, before: String, after: String, first: Int, last: Int): QuestionNodeConnection!
  answers(offset: Int, before: String, after: String, first: Int, last: Int): AnswerNodeConnection!
  votes(offset: Int, before: String, after: String, first: Int, last: Int): VoteNodeConnection!
}

input UserUpdateInput {
  username: String
  email: Email
  clientMutationId: String
}

type UserUpdatePayload {
  user: UserType
  clientMutationId: String
}

input VerifyInput {
  token: String
  clientMutationId: String
}

type VerifyPayload {
  payload: GenericScalar!
  clientMutationId: String
}

input VoteCreateUpdateDeleteInput {
  credible: Boolean
  answerId: ID!
  clientMutationId: String
}

type VoteCreateUpdateDeletePayload {
  vote: VoteNode
  clientMutationId: String
}

type VoteNode implements Node {
  id: ID!
  createdAt: DateTime!
  user: UserType!
  answer: AnswerNode!
  credible: Boolean
}

type VoteNodeConnection {
  pageInfo: PageInfo!
  edges: [VoteNodeEdge]!
}

type VoteNodeEdge {
  node: VoteNode
  cursor: String!
}
